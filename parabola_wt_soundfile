#!/usr/bin/env python
# -*- coding: utf-8 -*-

import numpy as np
import soundfile as sf
import matplotlib.pyplot as plt
import struct
import os

"""
TODO: args all opt
num_samples
num_waveforms
bitwidth
middle part divider
parabola a quantity
"""

num_samples = 2048    # Number of samples in one cycle
num_waveforms = 256   # Number of waveforms
sample_rate = 44100   # Sampling rate in Hz
bitwidth = 32
middle_samples = num_samples // 3  # Number of samples to overwrite the middle
middle_diff = 0.025

a = 0.1  # Parabola coefficient

# Generate the x-coordinates for one cycle
x = np.linspace(-1, 1, num_samples)  # x-coordinates for one cycle

waveforms = np.zeros((num_waveforms, num_samples))
for waveform_index in range(num_waveforms):
    y1 = a * x[:num_samples//2] ** 2 * -1.0 - middle_diff
    y2 = a * x[num_samples//2:] ** 2        + middle_diff
    waveform = np.concatenate((y1, y2))
    cur_mid_samples = middle_samples // num_waveforms*(waveform_index+1)
    start_index = (num_samples - cur_mid_samples) // 2
    end_index = start_index + cur_mid_samples
    ml_start = y1[-1-waveform_index] if len(y1) > 0 else 0
    ml_stop = y2[waveform_index] if len(y2) > 0 else 0
    middle_line = np.linspace(ml_start, ml_stop, cur_mid_samples)
    waveform[start_index:end_index] = middle_line
    waveforms[waveform_index] = waveform

# Flatten the waveforms to create consecutive frames
consecutive_frames = waveforms.flatten()

# Normalize the frames to the range of -1 to 1
normalized_frames = consecutive_frames / np.max(np.abs(consecutive_frames))

if bitwidth == 32:
    normalized_frames_typed = normalized_frames.astype(np.float32)
    wav_type = 'FLOAT'

elif bitwidth == 16:
    # Convert frames to 16-bit signed integer format
    normalized_frames_typed = (normalized_frames * 32767).astype(np.int16)
    wav_type = 'PCM_16'

else:
    print(f'wrong bitwidth: {bitwidth}')
    exit()

sf.write(f'sf_{bitwidth}_{num_samples}.wav', normalized_frames_typed, sample_rate, wav_type)

def add_chunk(src_name, dst_name, chunk):
    chid, size = struct.unpack('<4sI', chunk[:8])
    print(f'New chunk ID: {chid}, size: {size}, len: {len(chunk)}')
    dst = open(dst_name, 'wb')
    with open(src_name, 'rb') as src:
        data = src.read(12)
        riff, size, fformat = struct.unpack('<4sI4s', data)
        print(f'RIFF header: {riff}, size: {size}, format: {fformat}')
        dst.write(data)
        while True:
            try:
                # Each chunk starts with a 4-byte ID and a 4-byte size
                head = src.read(8)
                chid, size = struct.unpack('<4sI', head)
                print(f'Chunk ID: {chid}, size: {size}')
                data = src.read(size)
                print(f'read size: {len(data)}')
                if chid in [b'PEAK', b'fact']:
                    continue
                elif chid == b'data':
                    # write newck before b'data'
                    dst.write(newck)
                dst.write(head)
                dst.write(data)

            except struct.error:
                # If struct.unpack fails, it means we've run out of data, so we break the loop
                #print(f'ERR/END: ID: {chid}, size: {size}')
                break

    dst_size = os.fstat(dst.fileno()).st_size
    dst.seek(4)
    dst.write((dst_size-8).to_bytes(4, 'little'))
    dst.close()


newck = bytearray(b'srge')
newck.extend((8).to_bytes(4, 'little'))
newck.extend((1).to_bytes(4, 'little'))
newck.extend(num_samples.to_bytes(4, 'little'))
#print(len(newck); hexdump(newck)

add_chunk(
    f'sf_{bitwidth}_{num_samples}.wav',
    f'sf_{bitwidth}_{num_samples}_surge.wav',
    newck
)

# 00 00 00 00 00 01 00 00 -> 256
# 00 00 00 00 54 00 00 00 -> 84
newck = bytearray(b'uhWT')
newck.extend((272).to_bytes(4, 'little'))
newck.extend(b'\x00' * 4)
newck.extend(num_waveforms.to_bytes(2, 'little'))
newck.extend(b'\x00\x00\x00\x08\x00\x00\x00\x00\x00\x00')
newck.extend(b'Funny string')
newck.extend(b'\x00' * (272-len(newck)+8))
#print(len(newck); hexdump(newck)

add_chunk(
    f'sf_{bitwidth}_{num_samples}.wav',
    f'sf_{bitwidth}_{num_samples}_uhe.wav',
    newck
)

exit()

# Plot all waveforms at once
plt.plot(x, waveforms.T)  # Transpose the array for proper plotting

plt.xlabel('Sample')
plt.ylabel('Amplitude')
plt.title('Array of Waveforms')
plt.show()

