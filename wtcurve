#!/usr/bin/env python
# -*- coding: utf-8 -*-

from argparser_config import setup_parser
import numpy as np
from scipy.signal import savgol_filter
from scipy.ndimage import gaussian_filter1d
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from mpl_toolkits.mplot3d import Axes3D
import subprocess
import libwt


def debug(msg):
    if args.debug:
        print(msg)


def exp_curve(x1, y1, x2, y2, num_points):
    debug(f'curve: {x1} {y1} {x2} {y2} {num_points}')
    x = np.linspace(x1, x2, num_points)
    y = y1 + (y2 - y1) * (np.exp(args.exp * (x - x1)) - 1) / \
        (np.exp(args.exp * (x2 - x1)) - 1)
    if x1 < 0:
        y_rotated = y2 - (y - y1)
        return y_rotated[::-1]

    return y


def bezier_curve(x1, y1, x2, y2, num_points):
    t_values = np.linspace(0.0, 1.0, num_points)
    # pre-allocate to improve performance
    x_values = np.zeros(num_points)
    y_values = np.zeros(num_points)
    x = np.where(x1 < 0, x1, x2)
    y = np.where(x1 < 0, y2, y1)

    for i, t in enumerate(t_values):
        x_values[i] = (1 - t)**2 * x1 + 2 * (1 - t) * t * x + t**2 * x2
        y_values[i] = (1 - t)**2 * y1 + 2 * (1 - t) * t * y + t**2 * y2

    return y_values


def line(x1, y1, x2, y2, num_points):
    debug(f'line: {x1} {y1} {x2} {y2} {num_points}')
    if x1 == x2:
        y_values = np.linspace(y1, y2, num_points)
    else:
        x_values = np.linspace(x1, x2, num_points)
        y_values = y1 + ((y2 - y1) / (x2 - x1)) * (x_values - x1)
    return y_values


def fmt_fn(ext, add=None):
    fn = f'%dm_%dh_%s%s' % (args.mid_width_pct, args.mid_yoffset,
                            mtype, suffix)
    if ext in ['wav', 'wt']:
        if args.fullname:
            fn = f'{fn}_%ds_%dw' % (
                args.num_samples,
                args.num_waveforms)
    elif ext == 'gif':
        fn = f'{fn}_anim'
    elif ext not in ['png', 'h2p']:
        exit(1)

    fn += f'_{add}' if add else ''
    return f'{fn}.{ext}'


argp = setup_parser()
args = argp.parse_args()

if not (args.wav or args.graph or args.graph3d or args.debug or
        args.gif or args.h2p or args.wt):
    print(f'What to do?\n\n{argp.format_help()}')
    exit()

if args.bezier:
    curve_fn = bezier_curve
    title = 'BÃ©zier curve'
    mtype = 'bz'
elif args.direct:
    curve_fn = line
    title = 'Direct line'
    mtype = 'dl'
else:
    curve_fn = exp_curve
    title = 'Exponential curve'
    mtype = f'{args.exp}e'
suffix=''
if args.savgol:
    title = f'{title} savgol={args.savgol}'
    suffix = f'{suffix}_sg{args.savgol[0]}-{args.savgol[1]}'
if args.gauss:
    title = f'{title} gauss={args.gauss}'
    suffix = f'{suffix}_ga{args.gauss}'
if args.bitcrush:
    title = f'{title} bitcrush={args.bitcrush}'
    suffix = f'{suffix}_bc{args.bitcrush}'
if args.tanh:
    title = f'{title} tanh={args.tanh}'
    suffix = f'{suffix}_tanh{str(args.tanh).replace(".","-")}'
if args.dco:
    title = f'{title} dco'
    suffix = f'{suffix}_dco'

if args.h2p:
    args.num_samples = 128
    args.num_waveforms = 16

mid_samples = int((args.mid_width_pct / 100) * args.num_samples)
mid_samples -= mid_samples % 2
debug(f'mid_samples: {mid_samples} ({args.mid_width_pct}% of {args.num_samples})')

mid_widths = np.round(mid_samples * np.arange(args.num_waveforms) /
                      (args.num_waveforms - 1)).astype(int)
mid_widths -= mid_widths % 2
debug(f'mid_widths: {mid_widths}')

mid_yoffset = args.mid_yoffset * 0.01
# debug(f'mid_yoffset: {mid_yoffset}')

wf = np.zeros((args.num_waveforms, args.num_samples))
debug(f'wf shape: {wf.shape}')
xoffsets = np.linspace(0, args.mid_width_pct / 100, args.num_waveforms)

for i in range(args.num_waveforms):
    cx = xoffsets[i]
    debug(f'cx: {cx}')

    curve_len = args.num_samples // 2 - mid_widths[i] // 2
    debug(
        f'i: {i} curve_len: {curve_len}, mw: {mid_widths[i]}, '
        f'sum: {curve_len*2+mid_widths[i]}')

    ya1 = curve_fn(-1, -1, -cx, -mid_yoffset, curve_len)
    debug(f'ya1: {ya1} ({len(ya1)})')
    ya2 = curve_fn(cx, mid_yoffset, 1, 1, curve_len)
    debug(f'ya2: {ya2} ({len(ya2)})')
    ym = line(-cx, -mid_yoffset, cx, mid_yoffset, mid_widths[i])
    debug(f'ym: {ym} ({len(ym)})')
    y = np.concatenate((ya1, ym, ya2))
    debug(f'y: {y} {y.shape}')
    if args.savgol:
        if not args.savgol[0] in range(1,100):
            print('savgol window should be in range 1-100%')
            exit()
        wlen = int(args.num_samples / 100 * args.savgol[0])
        y = savgol_filter(y, window_length=wlen, polyorder=args.savgol[1])
    if args.gauss:
        y = gaussian_filter1d(y, sigma=args.gauss)
    if args.bitcrush:
        max_val = 2**(args.bitcrush) - 1
        y = np.round(y * max_val) / max_val
    if args.tanh:
        y = np.tanh(args.tanh * y)
    if args.dco:
        dc_offset = np.mean(y)
        y -= dc_offset


    wf[i] = y


if args.debug:
    np.set_printoptions(threshold=np.inf, precision=None, suppress=True)
    print('full wavetable:', wf)
    exit()

np.set_printoptions(linewidth=100, precision=2, suppress=True)

plt.rcParams['xtick.labelsize'] = args.fontsize
plt.rcParams['ytick.labelsize'] = args.fontsize
plt.rcParams['figure.dpi'] = args.dpi

if args.graph:
    x = np.linspace(0, 100, args.num_samples)
    plt.xticks(np.arange(min(x), max(x)+1, 25))
    plt.plot(x,wf[0], 'm-', label='first waveform')
    plt.plot(x,wf[-1], 'c-', label='last waveform')
    ax = plt.gca()
    ax.xaxis.set_ticklabels([])
    plt.ylabel('Amplitude', fontsize=args.fontsize)
    plt.title(
        f'{title} e={args.exp} m={args.mid_width_pct}% '
        f'h={args.mid_yoffset}% '
        f's={args.num_samples} w={args.num_waveforms}',
        fontsize=args.fontsize)
    plt.grid(True)
    plt.legend(fontsize=args.fontsize)
    if args.png:
        fn = fmt_fn('png', '2d')
        plt.savefig(fn, dpi=args.dpi)
    plt.show()

if args.graph3d:
    x = np.arange(wf.shape[1])
    y = np.arange(wf.shape[0])
    x, y = np.meshgrid(x, y)
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    ax.plot_surface(x, y, wf, cmap='twilight')
    ax.view_init(elev=20, azim=250)
    ax.grid(False)
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_zticks([])
    plt.title(
        f'{title} e={args.exp} m={args.mid_width_pct}% '
        f'h={args.mid_yoffset}%',
        y=0.95,
        fontsize=args.fontsize)
    plt.subplots_adjust(bottom=0, top=1.03)
    if args.png:
        fn = fmt_fn('png', '3d')
        plt.savefig(fn, dpi=int(args.dpi*1.2), pad_inches=0)
    plt.show()

if args.gif:
    pct1 = args.num_waveforms / 100
    fig, ax = plt.subplots()
    lines = []
    for pct in range(0, 100, 20):
        line, = ax.plot(wf[int(pct*pct1)], 'm-')
        lines.append([line])
    ax.xaxis.set_ticklabels([])
    ax.set_ylabel('Amplitude', fontsize=args.fontsize)
    param = '' if args.bezier or args.direct else f'e={args.exp} '
    ax.set_title(
        f'{title} {param}m={args.mid_width_pct}% '
        f'h={args.mid_yoffset}%',
        fontsize=args.fontsize)
    ax.grid(True)
    anim = animation.ArtistAnimation(fig, lines, interval=500, blit=True)
    fn = fmt_fn('gif')
    print(f'saving: {fn}')
    anim.save(fn, writer='pillow', dpi=args.dpi)
    if args.open:
        try:
            cmd = f'mimeopen {fn}'
            result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        except subprocess.CalledProcessError as e:
            print(e.returncode, e.stdout, e.stderr)

if args.wav:
    fn = fmt_fn('wav')
    print(f'saving: {fn} {args.bitwidth} bit')
    wt = libwt.Wt(wf, args.bitwidth)
    wt.save_wav(fn)

if args.wt:
    fn = fmt_fn('wt')
    print(f'saving: {fn} {args.bitwidth} bit')
    wt = libwt.Wt(wf, args.bitwidth)
    wt.save_wt(fn)

if args.h2p:
    fn = fmt_fn('h2p')
    print(f'saving: {fn}')
    wt = libwt.Wt(wf)
    wt.save_h2p(fn)

