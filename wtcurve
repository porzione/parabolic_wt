#!/usr/bin/env python
# -*- coding: utf-8 -*-

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import matplotlib.ticker as mticker
import libwtwav
from argparse import ArgumentParser

DEFAULTS = {
    "num_waveforms": 256,
    "num_samples": 2048,
    "bitwidth": 32,
    "dpi": 200,
    "exponent": 5,
    "mid_width_pct": 40,
    "mid_hoffset": 25
}


def debug(msg):
    if args.debug:
        print(msg)


def exp_curve(x1, y1, x2, y2, num_points):
    debug(f'curve: {x1} {y1} {x2} {y2} {num_points}')
    x = np.linspace(x1, x2, num_points)
    y = y1 + (y2 - y1) * (np.exp(args.exp * (x - x1)) - 1) / \
        (np.exp(args.exp * (x2 - x1)) - 1)
    if x1 < 0:
        y_rotated = y2 - (y - y1)
        return y_rotated[::-1]

    return y


def bezier_curve(x1, y1, x2, y2, num_points):
    t_values = np.linspace(0.0, 1.0, num_points)
    # pre-allocate to improve performance
    x_values = np.zeros(num_points)
    y_values = np.zeros(num_points)
    x = np.where(x1 < 0, x1, x2)
    y = np.where(x1 < 0, y2, y1)

    for i, t in enumerate(t_values):
        x_values[i] = (1 - t)**2 * x1 + 2 * (1 - t) * t * x + t**2 * x2
        y_values[i] = (1 - t)**2 * y1 + 2 * (1 - t) * t * y + t**2 * y2

    return y_values


def line(x1, y1, x2, y2, num_points):
    debug(f'line: {x1} {y1} {x2} {y2} {num_points}')
    if x1 == x2:
        y_values = np.linspace(y1, y2, num_points)
    else:
        x_values = np.linspace(x1, x2, num_points)
        y_values = y1 + ((y2 - y1) / (x2 - x1)) * (x_values - x1)
    return y_values


argp = ArgumentParser()
argp.add_argument(
    "-w", dest="num_waveforms", type=int,
    default=DEFAULTS['num_waveforms'],
    help="Number of frames/waveforms (%(default)s)")
argp.add_argument(
    "-s", dest="num_samples", type=int,
    default=DEFAULTS['num_samples'],
    choices=np.power(2, np.arange(4, 13)),
    help="Number of samples in one frame (%(default)s)")
argp.add_argument(
    "--bits", dest="bitwidth", type=int,
    default=DEFAULTS['bitwidth'],
    choices=[16, 32],
    help="Bits width (%(default)s)")
argp.add_argument(
    "-m", dest="mid_width_pct", type=int,
    default=DEFAULTS['mid_width_pct'],
    help="Percents in middle part (%(default)s)")
argp.add_argument(
    "-o", dest="mid_hoffset", type=int,
    default=DEFAULTS['mid_hoffset'],
    help="Percents of middle horizontal offset from y=0 (%(default)s)")
argp.add_argument(
    "-e", dest="exp", type=int,
    default=DEFAULTS['exponent'],
    choices=range(2, 10),
    help="Exponent of curve (%(default)s)")
argp.add_argument(
    "-B", action='store_true',
    dest="bezier", help="Build Bezier curve instead of exponent")
argp.add_argument(
    "--graph", action='store_true',
    dest="graph", help="Plot graph")
argp.add_argument(
    "--wav", action='store_true', dest="wav", help="Save wav")
argp.add_argument(
    "--gif", action='store_true', dest="gif", help="Save gif animation")
argp.add_argument(
    "--dpi", dest="dpi", type=int,
    help="Graph/gif DPI (%(default)s)",
    default=DEFAULTS['dpi'])
argp.add_argument(
    "-D", action='store_true', dest="debug", help="Debug")
args = argp.parse_args()

if not (args.wav or args.graph or args.debug or args.gif):
    print(f'What to do - wav or graph?\n\n{argp.format_help()}')
    exit()

if args.bezier:
    curve_fn = bezier_curve
    title = 'BÃ©zier'
else:
    curve_fn = exp_curve
    title = 'Exponential'

mid_samples = int((args.mid_width_pct / 100) * args.num_samples)
mid_samples -= mid_samples % 2
debug(f'mid_samples: {mid_samples} ({args.mid_width_pct}% of {args.num_samples})')

mid_widths = np.round(mid_samples * np.arange(args.num_waveforms) /
                      (args.num_waveforms - 1)).astype(int)
mid_widths -= mid_widths % 2
debug(f'mid_widths: {mid_widths}')

middle_hoffset = args.mid_hoffset * 0.01
# debug(f'middle_hoffset: {middle_hoffset}')

wf = np.zeros((args.num_waveforms, args.num_samples))
debug(f'wf shape: {wf.shape}')
xoffsets = np.linspace(0, args.mid_width_pct / 100, args.num_waveforms)

for i in range(args.num_waveforms):
    cx = xoffsets[i]
    debug(f'cx: {cx}')

    curve_len = args.num_samples // 2 - mid_widths[i] // 2
    debug(
        f'i: {i} curve_len: {curve_len}, mw: {mid_widths[i]}, '
        f'sum: {curve_len*2+mid_widths[i]}')

    ya1 = curve_fn(-1, -1, -cx, -middle_hoffset, curve_len)
    debug(f'ya1: {ya1} ({len(ya1)})')
    ya2 = curve_fn(cx, middle_hoffset, 1, 1, curve_len)
    debug(f'ya2: {ya2} ({len(ya2)})')
    ym = line(-cx, -middle_hoffset, cx, middle_hoffset, mid_widths[i])
    debug(f'ym: {ym} ({len(ym)})')
    y = np.concatenate((ya1, ym, ya2))
    debug(f'y: {y} {y.shape}')

    wf[i] = y

np.set_printoptions(linewidth=100, precision=2, suppress=True)

if args.debug:
    print(wf)
    exit()

if args.graph:
    plt.rcParams['figure.dpi'] = args.dpi
    plt.plot(wf[0], label='first')
    plt.plot(wf[-1], label='last')
    plt.xlabel('Sample')
    plt.ylabel('Amplitude')
    plt.title(
        f'{title} curve e={args.exp} m={args.mid_width_pct}% '
        f'h={args.mid_hoffset}% '
        f's={args.num_samples} w={args.num_waveforms}')
    plt.grid(True)
    plt.legend()
    plt.show()

if args.wav:
    fn = '%dm_%dh_%s_%ds_%dw_%db.wav' % (
         args.mid_width_pct,
         args.mid_hoffset,
         'bz' if args.bezier else f'{args.exp}e',
         args.num_samples,
         args.num_waveforms,
         args.bitwidth)
    print(f'saving: {fn}')
    wav = libwtwav.Wav(wf, args.bitwidth)
    wav.save(fn)

if args.gif:
    pct1 = args.num_waveforms / 100
    fig, ax = plt.subplots()
    lines = []
    for pct in range(0,100,20):
        line, = ax.plot(wf[int(pct*pct1)], 'b-')
        lines.append([line])
    ax.set_xlabel('Sample')
    ax.set_ylabel('Amplitude')
    param = '' if args.bezier else f'e={args.exp} '
    ax.set_title(
        f'{title} curve {param}m={args.mid_width_pct}% '
        f'h={args.mid_hoffset}%')
    ax.grid(True)
    anim = animation.ArtistAnimation(fig, lines, interval=500, blit=True)
    fn = '%dm_%dh_' % (args.mid_width_pct, args.mid_hoffset)
    fn += 'bz' if args.bezier else f'{args.exp}e'
    anim.save(f'wtc_{fn}_anim.gif', writer='pillow', dpi=args.dpi)

